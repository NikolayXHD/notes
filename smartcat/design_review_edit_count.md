Задача
------
Предоставить готовый для потребления на стороне команды BI набор данных о
количестве правок после некоторого автора.

За автора можем принимать
- конкретный user_id
- MT (mt_key либо mt_preset_id)
- TM match quality в ревизии с подстановкой TM

Набор данных должен быть ретроспективно наполнен на глубину 2г. в прошлое.

Триггер выгрузки
----------------
SingletonTaskprocessing, срабатывает раз в день по аналогии с
UserActivityStatisticsProcessor.

Фильтр
------
За один раз обрабатывается пачка с интервалом 10 минут по дате ревизии
сегмента. Чтобы минимизировать повторный анализ одного и того же сегмента, окно
10 минут должно смотреть не на любую дату ревизии, а на последнюю.

В SegmentTarget есть поле lastRevisionCreationTime. Если по этому полю не
окажется индекса, мы его добавим и будем использовать.

Глубина
-------

В первый раз пачками по 10 минут будут обработаны все сегменты за последние 2
года. Далее taskprocessing уснёт и будет просыпаться 1 раз в день.

Адрес выгрузки в базе
---------------------

Т.к. выгрузка нужна исключительно для BI, репозиторий для сохранения выгрузки
будет смотреть на отдельную от основной базы smartcat базу, например
smartcat_bi.

Таким образом
- мы избежим необоснованного раздувания списка коллекций основной базы
- изолируем потенциальные будущие проблемы таких коллекций от основной базы.

Структура выгрузки
------------------
Ключ = языкоэтап + автор
  языкоэтап = project_id + target_language_id + workflow_stage_type
  автор = user_id | mt_key | mt_preset_id | tm_match_quality
Значение = счётчики правок
  - всего переведено сегментов
  - суммарная длина source
    - в символах т.к. количество слов применимо не ко всем языкам
  - суммарная длина target
    - тоже в символах
    - максимальная из 2х длин
      - как её сделал автор
      - какая она стала после правок, исправляющих работу автора
  - сколько сегментов было исправлено
  - сколько раз сегмент был исправлен
    - отличается от "сколько сегментов было исправлено", т. к. в одном сегменте
      может быть "война правок", когда за автором правят больше одного раза.
  - сколько символов было изменено


Суммирование правок
-------------------
Каждый раз, когда автор произвёл подряд ревизии на данном этапе
workflow, мы считаем что он принял ответственность за результат.

- Последняя ревизия последовательности используется как начальное состояние для
  diff.
- Конечным состоянием для diff является последняя ревизия сегмента, либо
  последняя ревизия перед тем, как автор вернулся к правкам в данном сегменте.
  - Исключение, если автор вернулся к правкам в сегменте в рамках другого этапа
    workflow, конечное состояние для diff - последняя ревизия этого же автора
    в новой последовательности ревизий на новом этапе workflow.

Для каждой пары начальная / конечная ревизии данного автора, счётчики,
подпадающие под одинаковый ключ агрегации складываются.

Ретроспективное обновление счётчиков
------------------------------------
Когда в истории сегмента появляются новые ревизии, агрегат правок, в который
входит сегмент нужно обновить.

Просто так взять и обновить агрегат нельзя, т.к. для этого нужно знать,
какой вклад был конкретно у этого сегмента когда рассчитывалось последнее
значение агрегата.

Видно 2 варианта решения

Вариант 1. Хранить в базе не агрегат, а вклад в него индивидуального сегмента.
Вариант 2. Вытаскивать все сегменты проекта и считать заново.

Склоняюсь к 1-му т.к. он проще и след. надёжнее.

Опциональный шаг доработки модели сегментов в базе smartcat
-----------------------------------------------------------
В текущем виде моделей базы данных smartcat, в MT ревизии smartcat не хранится
ключ MT, его придётся join-ить в коде из коллекции
`Cat.Segments.MachineTranslations`.

Команда tat считает полезным изменение, когда в MT ревизии хранится этот ключ,
и предлагает реализовать его в рамках данной задачи по подсчёту количества
правок.

Оценочно, если так сделать, релиз задачи по подсчёту правок сдвинется на 3 дня
- 1. Написать / протестировать миграцию, ретроспективно заполняющую mt_key,
  mt_preset_id в старых сегментах.
- 2. Задеплоить smartcat миграцию без подсчёта количества правок, дождаться
  завершения

После этого уже можно будет деплоить собственно подсчёт количества правок.
